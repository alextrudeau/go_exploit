// Copyright 2019 DeepMind Technologies Ltd. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef OPEN_SPIEL_ALGORITHMS_ALPHA_ZERO_TORCH_ALPHA_ZERO_H_
#define OPEN_SPIEL_ALGORITHMS_ALPHA_ZERO_TORCH_ALPHA_ZERO_H_

#include <iostream>
#include <string>
#include <vector>

#include "open_spiel/utils/file.h"
#include "open_spiel/utils/json.h"
#include "open_spiel/utils/thread.h"
#include "open_spiel/utils/serializable_circular_buffer.h"
#include "open_spiel/abseil-cpp/absl/synchronization/mutex.h"
#include "open_spiel/spiel.h"
#include "open_spiel/spiel_utils.h"
#include "open_spiel/algorithms/alpha_zero_torch/vpnet.h"

namespace open_spiel {
namespace algorithms {
namespace torch_az {

struct ArchiveEntry {
  std::vector<open_spiel::Action> action_sequence;
  int depth;
};

struct KataGoInitData {
  std::shared_ptr<open_spiel::State> state;
  std::vector<open_spiel::Action> action_sequence;
  int depth;
};

// Either a Fixed-Size Circular Archive, a Fixed-Size Archive with Reservoir Sampling, or an Expanding Archive
class Archive {
  public:
    Archive(std::string archive_type, int max_size, unsigned seed, std::string path);
    ~Archive() = default;
    ArchiveEntry Sample();
    void Update(std::vector<ArchiveEntry>& step_archive);
  
  private:
    SerializableCircularBuffer<ArchiveEntry> fixed_size_archive_;
    std::vector<ArchiveEntry> expanding_archive_;
    std::vector<double> weights_;
    std::string archive_type_;
    int current_size_;
    int max_size_;
    int reservoir_index_;
    std::mt19937 rng_;
    std::string path_;
    absl::Mutex archive_mutex_;
};

class UpdateStates {
  public:
    UpdateStates() = default;
    ~UpdateStates() = default;
    void Update(std::vector<VPNetModel::TrainInputs> learn_inputs);
    int GetUpdateCount(std::string state_str);
    void Write(std::string path, int step);

  private:
    std::unordered_map<std::string, int> update_states_;
    absl::Mutex mutex_;
};

struct AlphaZeroConfig {
  std::string game;
  std::string path;
  std::string graph_def;
  std::string nn_model;
  int nn_width;
  int nn_depth;
  std::string devices;

  bool explicit_learning;
  double learning_rate;
  double weight_decay;
  int train_batch_size;
  int inference_batch_size;
  int inference_threads;
  int inference_cache;
  int replay_buffer_size;
  int replay_buffer_reuse;
  int checkpoint_freq;
  int evaluation_window;

  double uct_c;
  double eval_uct_c;
  int max_simulations;
  double policy_alpha;
  double policy_epsilon;
  double temperature;
  double temperature_drop;
  double cutoff_probability;
  double cutoff_value;

  int training_actors;
  int archive_actors;
  int evaluators;
  int eval_levels;
  int max_steps;

  double start_state_prob;
  bool use_search_states;
  std::string archive_type;
  int max_archive_size;

  bool katago_init;
  bool game_branching;
  bool position_branching;
  double board_width;
  double board_length;
  bool playout_cap;
  double full_search_prob;
  int fast_search;
  bool use_forced_playouts;

  bool write_search_stats;

  json::Object ToJson() const {
    return json::Object({
        {"game", game},
        {"path", path},
        {"graph_def", graph_def},
        {"nn_model", nn_model},
        {"nn_width", nn_width},
        {"nn_depth", nn_depth},
        {"devices", devices},
        {"explicit_learning", explicit_learning},
        {"learning_rate", learning_rate},
        {"weight_decay", weight_decay},
        {"train_batch_size", train_batch_size},
        {"inference_batch_size", inference_batch_size},
        {"inference_threads", inference_threads},
        {"inference_cache", inference_cache},
        {"replay_buffer_size", replay_buffer_size},
        {"replay_buffer_reuse", replay_buffer_reuse},
        {"checkpoint_freq", checkpoint_freq},
        {"evaluation_window", evaluation_window},
        {"uct_c", uct_c},
        {"eval_uct_c", eval_uct_c},
        {"max_simulations", max_simulations},
        {"policy_alpha", policy_alpha},
        {"policy_epsilon", policy_epsilon},
        {"temperature", temperature},
        {"temperature_drop", temperature_drop},
        {"cutoff_probability", cutoff_probability},
        {"cutoff_value", cutoff_value},
        {"training_actors", training_actors},
        {"archive_actors", archive_actors},
        {"evaluators", evaluators},
        {"eval_levels", eval_levels},
        {"max_steps", max_steps},
        {"start_state_prob", start_state_prob},
        {"use_search_states", use_search_states},
        {"archive_type", archive_type},
        {"max_archive_size", max_archive_size},
        {"katago_init", katago_init},
        {"game_branching", game_branching},
        {"position_branching", position_branching},
        {"board_width", board_width},
        {"board_length", board_length},
        {"playout_cap", playout_cap},
        {"full_search_prob", full_search_prob},
        {"fast_search", fast_search},
        {"use_forced_playouts", use_forced_playouts},
        {"write_search_stats", write_search_stats},
    });
  }

  void FromJson(const json::Object& config_json) {
    game = config_json.at("game").GetString();
    path = config_json.at("path").GetString();
    graph_def = config_json.at("graph_def").GetString();
    nn_model = config_json.at("nn_model").GetString();
    nn_width = config_json.at("nn_width").GetInt();
    nn_depth = config_json.at("nn_depth").GetInt();
    devices = config_json.at("devices").GetString();
    explicit_learning = config_json.at("explicit_learning").GetBool();
    learning_rate = config_json.at("learning_rate").GetDouble();
    weight_decay = config_json.at("weight_decay").GetDouble();
    train_batch_size = config_json.at("train_batch_size").GetInt();
    inference_batch_size = config_json.at("inference_batch_size").GetInt();
    inference_threads = config_json.at("inference_threads").GetInt();
    inference_cache = config_json.at("inference_cache").GetInt();
    replay_buffer_size = config_json.at("replay_buffer_size").GetInt();
    replay_buffer_reuse = config_json.at("replay_buffer_reuse").GetInt();
    checkpoint_freq = config_json.at("checkpoint_freq").GetInt();
    evaluation_window = config_json.at("evaluation_window").GetInt();
    uct_c = config_json.at("uct_c").GetDouble();
    eval_uct_c = config_json.at("eval_uct_c").GetDouble();
    max_simulations = config_json.at("max_simulations").GetInt();
    policy_alpha = config_json.at("policy_alpha").GetDouble();
    policy_epsilon = config_json.at("policy_epsilon").GetDouble();
    temperature = config_json.at("temperature").GetDouble();
    temperature_drop = config_json.at("temperature_drop").GetDouble();
    cutoff_probability = config_json.at("cutoff_probability").GetDouble();
    cutoff_value = config_json.at("cutoff_value").GetDouble();
    training_actors = config_json.at("training_actors").GetInt();
    archive_actors = config_json.at("archive_actors").GetInt();
    evaluators = config_json.at("evaluators").GetInt();
    eval_levels = config_json.at("eval_levels").GetInt();
    max_steps = config_json.at("max_steps").GetInt();
    start_state_prob = config_json.at("start_state_prob").GetDouble();
    use_search_states = config_json.at("use_search_states").GetBool();
    archive_type = config_json.at("archive_type").GetString();
    max_archive_size = config_json.at("max_archive_size").GetInt();
    katago_init = config_json.at("katago_init").GetBool();
    game_branching = config_json.at("game_branching").GetBool();
    position_branching = config_json.at("position_branching").GetBool();
    board_width = config_json.at("board_width").GetDouble();
    board_length = config_json.at("board_length").GetDouble();
    playout_cap = config_json.at("playout_cap").GetBool();
    full_search_prob = config_json.at("full_search_prob").GetDouble();
    fast_search = config_json.at("fast_search").GetInt();
    use_forced_playouts = config_json.at("use_forced_playouts").GetBool();
    write_search_stats = config_json.at("write_search_stats").GetBool();
  }
};

bool AlphaZero(AlphaZeroConfig config, StopToken* stop, bool resuming);

}  // namespace torch_az
}  // namespace algorithms
}  // namespace open_spiel

#endif  // OPEN_SPIEL_ALGORITHMS_ALPHA_ZERO_TORCH_ALPHA_ZERO_H_
